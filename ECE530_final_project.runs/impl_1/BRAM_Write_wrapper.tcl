# 
# Report generation script generated by Vivado
# 

proc create_report { reportName command } {
  set status "."
  append status $reportName ".fail"
  if { [file exists $status] } {
    eval file delete [glob $status]
  }
  send_msg_id runtcl-4 info "Executing : $command"
  set retval [eval catch { $command } msg]
  if { $retval != 0 } {
    set fp [open $status w]
    close $fp
    send_msg_id runtcl-5 warning "$msg"
  }
}
proc start_step { step } {
  set stopFile ".stop.rst"
  if {[file isfile .stop.rst]} {
    puts ""
    puts "*** Halting run - EA reset detected ***"
    puts ""
    puts ""
    return -code error
  }
  set beginFile ".$step.begin.rst"
  set platform "$::tcl_platform(platform)"
  set user "$::tcl_platform(user)"
  set pid [pid]
  set host ""
  if { [string equal $platform unix] } {
    if { [info exist ::env(HOSTNAME)] } {
      set host $::env(HOSTNAME)
    }
  } else {
    if { [info exist ::env(COMPUTERNAME)] } {
      set host $::env(COMPUTERNAME)
    }
  }
  set ch [open $beginFile w]
  puts $ch "<?xml version=\"1.0\"?>"
  puts $ch "<ProcessHandle Version=\"1\" Minor=\"0\">"
  puts $ch "    <Process Command=\".planAhead.\" Owner=\"$user\" Host=\"$host\" Pid=\"$pid\">"
  puts $ch "    </Process>"
  puts $ch "</ProcessHandle>"
  close $ch
}

proc end_step { step } {
  set endFile ".$step.end.rst"
  set ch [open $endFile w]
  close $ch
}

proc step_failed { step } {
  set endFile ".$step.error.rst"
  set ch [open $endFile w]
  close $ch
}

set_msg_config -id {HDL-1065} -limit 10000
set_msg_config  -ruleid {1}  -id {Place 30-575}  -string {{ERROR: [Place 30-575] Sub-optimal placement for a clock-capable IO pin and MMCM pair. If this sub optimal condition is acceptable for this design, you may use the CLOCK_DEDICATED_ROUTE constraint in the .xdc file to demote this message to a WARNING. However, the use of this override is highly discouraged. These examples can be used directly in the .xdc file to override this clock rule.
	< set_property CLOCK_DEDICATED_ROUTE BACKBONE [get_nets design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/CLK_IN_hdmi_clk] >

	design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/InputBuffer (IBUFDS.O) is locked to IOB_X0Y74
	 design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/DVI_ClkGenerator (MMCME2_ADV.CLKIN1) is provisionally placed by clockplacer on MMCME2_ADV_X0Y0

	The above error could possibly be related to other connected instances. Following is a list of 
	all the related clock rules and their respective instances.

	Clock Rule: rule_bufh_bufr_ramb
	Status: PASS 
	Rule Description: Reginal buffers in the same clock region must drive a total number of brams less
	than the capacity of the region
	 design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/PixelClkBuffer (BUFR.O) is provisionally placed by clockplacer on BUFR_X0Y7

	Clock Rule: rule_bufr_IoClkLds
	Status: PASS 
	Rule Description: A BUFR driving any number of IOBs must be placed within the same clock region
	 design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/PixelClkBuffer (BUFR.O) is provisionally placed by clockplacer on BUFR_X0Y7
	 design_1_i/dvi2rgb_0/U0/DataDecoders[1].DecoderX/InputSERDES_X/DeserializerMaster (ISERDESE2.CLKDIV) is locked to ILOGIC_X0Y98
	 design_1_i/dvi2rgb_0/U0/DataDecoders[1].DecoderX/InputSERDES_X/DeserializerSlave (ISERDESE2.CLKDIV) is locked to ILOGIC_X0Y97
	 design_1_i/dvi2rgb_0/U0/DataDecoders[1].DecoderX/InputSERDES_X/InputDelay (IDELAYE2.C) is locked to IDELAY_X0Y98
	 design_1_i/dvi2rgb_0/U0/DataDecoders[2].DecoderX/InputSERDES_X/DeserializerMaster (ISERDESE2.CLKDIV) is locked to ILOGIC_X0Y96
	 design_1_i/dvi2rgb_0/U0/DataDecoders[2].DecoderX/InputSERDES_X/DeserializerSlave (ISERDESE2.CLKDIV) is locked to ILOGIC_X0Y95
	 design_1_i/dvi2rgb_0/U0/DataDecoders[2].DecoderX/InputSERDES_X/InputDelay (IDELAYE2.C) is locked to IDELAY_X0Y96
	 design_1_i/dvi2rgb_0/U0/DataDecoders[0].DecoderX/InputSERDES_X/DeserializerMaster (ISERDESE2.CLKDIV) is locked to ILOGIC_X0Y92
	 design_1_i/dvi2rgb_0/U0/DataDecoders[0].DecoderX/InputSERDES_X/DeserializerSlave (ISERDESE2.CLKDIV) is locked to ILOGIC_X0Y91
	 design_1_i/dvi2rgb_0/U0/DataDecoders[0].DecoderX/InputSERDES_X/InputDelay (IDELAYE2.C) is locked to IDELAY_X0Y92

	Clock Rule: rule_bufr_bufg
	Status: PASS 
	Rule Description: A BUFR driving a BUFG must be placed on the same half side (top/bottom) of the device
	 design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/PixelClkBuffer (BUFR.O) is provisionally placed by clockplacer on BUFR_X0Y7
	 design_1_i/dvi2rgb_0/U0/GenerateBUFG.ResyncToBUFG_X/InstBUFG (BUFG.I) is provisionally placed by clockplacer on BUFGCTRL_X0Y19

	Clock Rule: rule_clk_locked_loads
	Status: PASS 
	Rule Description NOT AVAILABLE
	 design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/PixelClkBuffer (BUFR.O) is provisionally placed by clockplacer on BUFR_X0Y7
	 design_1_i/dvi2rgb_0/U0/DataDecoders[1].DecoderX/InputSERDES_X/InputDelay (IDELAYE2.C) is locked to IDELAY_X0Y98
	 design_1_i/dvi2rgb_0/U0/DataDecoders[2].DecoderX/InputSERDES_X/InputDelay (IDELAYE2.C) is locked to IDELAY_X0Y96
	 design_1_i/dvi2rgb_0/U0/DataDecoders[0].DecoderX/InputSERDES_X/InputDelay (IDELAYE2.C) is locked to IDELAY_X0Y92

	Clock Rule: rule_bufio_clklds
	Status: PASS 
	Rule Description: A BUFIO driving any number of IOBs must be placed within the same bank. In V7, there
	is at most one IO bank in  each clock region so the SameClockRegion rule is sufficient to satisfy the
	requirement.
	 design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/SerialClkBuffer (BUFIO.O) is provisionally placed by clockplacer on BUFIO_X0Y7
	 design_1_i/dvi2rgb_0/U0/DataDecoders[1].DecoderX/InputSERDES_X/DeserializerMaster (ISERDESE2.CLKB) is locked to ILOGIC_X0Y98
	 design_1_i/dvi2rgb_0/U0/DataDecoders[1].DecoderX/InputSERDES_X/DeserializerSlave (ISERDESE2.CLKB) is locked to ILOGIC_X0Y97
	 design_1_i/dvi2rgb_0/U0/DataDecoders[2].DecoderX/InputSERDES_X/DeserializerMaster (ISERDESE2.CLKB) is locked to ILOGIC_X0Y96
	 design_1_i/dvi2rgb_0/U0/DataDecoders[2].DecoderX/InputSERDES_X/DeserializerSlave (ISERDESE2.CLKB) is locked to ILOGIC_X0Y95
	 design_1_i/dvi2rgb_0/U0/DataDecoders[0].DecoderX/InputSERDES_X/DeserializerMaster (ISERDESE2.CLKB) is locked to ILOGIC_X0Y92
	 design_1_i/dvi2rgb_0/U0/DataDecoders[0].DecoderX/InputSERDES_X/DeserializerSlave (ISERDESE2.CLKB) is locked to ILOGIC_X0Y91

	Clock Rule: rule_mmcm_bufr_bufio
	Status: FAIL 
	Rule Description: An MMCM driving a BUFR/BUFIO must both be in the same clock region
	 design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/DVI_ClkGenerator (MMCME2_ADV.CLKOUT0) is provisionally placed by clockplacer on MMCME2_ADV_X0Y0
	 design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/SerialClkBuffer (BUFIO.I) is provisionally placed by clockplacer on BUFIO_X0Y7
	 design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/PixelClkBuffer (BUFR.I) is provisionally placed by clockplacer on BUFR_X0Y7
	ERROR: The above is also an illegal clock rule
	Workaround: < set_property CLOCK_DEDICATED_ROUTE ANY_CMT_COLUMN [get_nets design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/CLK_OUT_5x_hdmi_clk] >

	Clock Rule: rule_mmcm_mmcm
	Status: PASS 
	Rule Description: An MMCM driving an MMCM must be in the same CMT column, and they are adjacent to
	each other (vertically), if the  CLOCK_DEDICATED_ROUTE=BACKBONE constraint is NOT set
	 design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/DVI_ClkGenerator (MMCME2_ADV.CLKFBOUT) is provisionally placed by clockplacer on MMCME2_ADV_X0Y0
	 and design_1_i/dvi2rgb_0/U0/TMDS_ClockingX/DVI_ClkGenerator (MMCME2_ADV.CLKFBIN) is provisionally placed by clockplacer on MMCME2_ADV_X0Y0

Resolution: A dedicated routing path between the two can be used if: (a) The clock-capable IO (CCIO) is placed on a CCIO capable site (b) The MMCM is placed in the same clock region as the CCIO pin. If the IOB is driving multiple MMCMs, all MMCMs must be placed in the same clock region, one clock region above or one clock region below the IOB. Both the above conditions must be met at the same time, else it may lead to longer and less predictable clock insertion delays.}}  -suppress 
set_msg_config  -ruleid {2}  -id {Place 30-99}  -string {{ERROR: [Place 30-99] Placer failed with error: 'IO Clock Placer failed'
Please review all ERROR, CRITICAL WARNING, and WARNING messages during placement to understand the cause for failure.}}  -suppress 

start_step init_design
set ACTIVE_STEP init_design
set rc [catch {
  create_msg_db init_design.pb
  set_param tcl.collectionResultDisplayLimit 0
  set_param xicom.use_bs_reader 1
  create_project -in_memory -part xc7z010clg400-1
  set_property board_part digilentinc.com:zybo:part0:1.0 [current_project]
  set_property design_mode GateLvl [current_fileset]
  set_param project.singleFileAddWarning.threshold 0
  set_property webtalk.parent_dir C:/Users/murakar/xup/embedded/2015_2_zynq_labs/ECE530_final_project/ECE530_final_project.cache/wt [current_project]
  set_property parent.project_path C:/Users/murakar/xup/embedded/2015_2_zynq_labs/ECE530_final_project/ECE530_final_project.xpr [current_project]
  set_property ip_repo_paths {
  C:/Users/murakar/xup/embedded/2015_2_zynq_labs/PS_PL_coop/ip_repo/myip_1.0
  C:/Users/murakar/xup/embedded/2015_2_zynq_labs/PS_PL_coop/ip_repo/myBram_1.0
  C:/Users/murakar/xup/vivado-library
  C:/Users/murakar/xup/embedded/2015_2_zynq_labs/BRAM_ip/ip_repo/BRAM_ip_1.0
} [current_project]
  set_property ip_output_repo C:/Users/murakar/xup/embedded/2015_2_zynq_labs/ECE530_final_project/ECE530_final_project.cache/ip [current_project]
  set_property ip_cache_permissions {read write} [current_project]
  set_property XPM_LIBRARIES {XPM_CDC XPM_FIFO XPM_MEMORY} [current_project]
  add_files -quiet C:/Users/murakar/xup/embedded/2015_2_zynq_labs/ECE530_final_project/ECE530_final_project.runs/synth_1/BRAM_Write_wrapper.dcp
  set_msg_config -source 4 -id {BD 41-1661} -limit 0
  set_param project.isImplRun true
  add_files C:/Users/murakar/xup/embedded/2015_2_zynq_labs/ECE530_final_project/ECE530_final_project.srcs/sources_1/bd/BRAM_Write/BRAM_Write.bd
  set_param project.isImplRun false
  read_xdc C:/Users/murakar/xup/embedded/2015_2_zynq_labs/ECE530_final_project/ECE530_final_project.srcs/constrs_1/imports/IMGProcess/dvi2vga.xdc
  set_param project.isImplRun true
  link_design -top BRAM_Write_wrapper -part xc7z010clg400-1
  set_param project.isImplRun false
  write_hwdef -force -file BRAM_Write_wrapper.hwdef
  close_msg_db -file init_design.pb
} RESULT]
if {$rc} {
  step_failed init_design
  return -code error $RESULT
} else {
  end_step init_design
  unset ACTIVE_STEP 
}

start_step opt_design
set ACTIVE_STEP opt_design
set rc [catch {
  create_msg_db opt_design.pb
  opt_design 
  write_checkpoint -force BRAM_Write_wrapper_opt.dcp
  create_report "impl_1_opt_report_drc_0" "report_drc -file BRAM_Write_wrapper_drc_opted.rpt -pb BRAM_Write_wrapper_drc_opted.pb -rpx BRAM_Write_wrapper_drc_opted.rpx"
  close_msg_db -file opt_design.pb
} RESULT]
if {$rc} {
  step_failed opt_design
  return -code error $RESULT
} else {
  end_step opt_design
  unset ACTIVE_STEP 
}

start_step place_design
set ACTIVE_STEP place_design
set rc [catch {
  create_msg_db place_design.pb
  if { [llength [get_debug_cores -quiet] ] > 0 }  { 
    implement_debug_core 
  } 
  place_design 
  write_checkpoint -force BRAM_Write_wrapper_placed.dcp
  create_report "impl_1_place_report_io_0" "report_io -file BRAM_Write_wrapper_io_placed.rpt"
  create_report "impl_1_place_report_utilization_0" "report_utilization -file BRAM_Write_wrapper_utilization_placed.rpt -pb BRAM_Write_wrapper_utilization_placed.pb"
  create_report "impl_1_place_report_control_sets_0" "report_control_sets -verbose -file BRAM_Write_wrapper_control_sets_placed.rpt"
  close_msg_db -file place_design.pb
} RESULT]
if {$rc} {
  step_failed place_design
  return -code error $RESULT
} else {
  end_step place_design
  unset ACTIVE_STEP 
}

start_step route_design
set ACTIVE_STEP route_design
set rc [catch {
  create_msg_db route_design.pb
  route_design 
  write_checkpoint -force BRAM_Write_wrapper_routed.dcp
  create_report "impl_1_route_report_drc_0" "report_drc -file BRAM_Write_wrapper_drc_routed.rpt -pb BRAM_Write_wrapper_drc_routed.pb -rpx BRAM_Write_wrapper_drc_routed.rpx"
  create_report "impl_1_route_report_methodology_0" "report_methodology -file BRAM_Write_wrapper_methodology_drc_routed.rpt -pb BRAM_Write_wrapper_methodology_drc_routed.pb -rpx BRAM_Write_wrapper_methodology_drc_routed.rpx"
  create_report "impl_1_route_report_power_0" "report_power -file BRAM_Write_wrapper_power_routed.rpt -pb BRAM_Write_wrapper_power_summary_routed.pb -rpx BRAM_Write_wrapper_power_routed.rpx"
  create_report "impl_1_route_report_route_status_0" "report_route_status -file BRAM_Write_wrapper_route_status.rpt -pb BRAM_Write_wrapper_route_status.pb"
  create_report "impl_1_route_report_timing_summary_0" "report_timing_summary -max_paths 10 -file BRAM_Write_wrapper_timing_summary_routed.rpt -pb BRAM_Write_wrapper_timing_summary_routed.pb -rpx BRAM_Write_wrapper_timing_summary_routed.rpx -warn_on_violation "
  create_report "impl_1_route_report_incremental_reuse_0" "report_incremental_reuse -file BRAM_Write_wrapper_incremental_reuse_routed.rpt"
  create_report "impl_1_route_report_clock_utilization_0" "report_clock_utilization -file BRAM_Write_wrapper_clock_utilization_routed.rpt"
  create_report "impl_1_route_report_bus_skew_0" "report_bus_skew -warn_on_violation -file BRAM_Write_wrapper_bus_skew_routed.rpt -pb BRAM_Write_wrapper_bus_skew_routed.pb -rpx BRAM_Write_wrapper_bus_skew_routed.rpx"
  close_msg_db -file route_design.pb
} RESULT]
if {$rc} {
  write_checkpoint -force BRAM_Write_wrapper_routed_error.dcp
  step_failed route_design
  return -code error $RESULT
} else {
  end_step route_design
  unset ACTIVE_STEP 
}

start_step write_bitstream
set ACTIVE_STEP write_bitstream
set rc [catch {
  create_msg_db write_bitstream.pb
  set_property XPM_LIBRARIES {XPM_CDC XPM_FIFO XPM_MEMORY} [current_project]
  catch { write_mem_info -force BRAM_Write_wrapper.mmi }
  catch { write_bmm -force BRAM_Write_wrapper_bd.bmm }
  write_bitstream -force BRAM_Write_wrapper.bit 
  catch { write_sysdef -hwdef BRAM_Write_wrapper.hwdef -bitfile BRAM_Write_wrapper.bit -meminfo BRAM_Write_wrapper.mmi -file BRAM_Write_wrapper.sysdef }
  catch {write_debug_probes -quiet -force BRAM_Write_wrapper}
  catch {file copy -force BRAM_Write_wrapper.ltx debug_nets.ltx}
  close_msg_db -file write_bitstream.pb
} RESULT]
if {$rc} {
  step_failed write_bitstream
  return -code error $RESULT
} else {
  end_step write_bitstream
  unset ACTIVE_STEP 
}

